/*
===============================================================================
  Gulp Vue-Split
  Copyright 2016 Sebastian Software GmbH <https://www.sebastian-software.de>
===============================================================================
*/

import through from "through2"
import parse5 from "parse5"
import deindent from "de-indent"
import File from "vinyl"
import postcss from "postcss"
import series from "async/series"
import posthtml from "posthtml"
import postcssModules from "postcss-modules"
import templateValidate from "vue-template-validator"
import htmlMinifier from "html-minifier"
import pathModule from "path"
import objectGet from "lodash/get"
import parseAttrs from "posthtml-attrs-parser"
import crc from "crc"
import gutil from "gulp-util"

var memCache =
{
  css: {},
  html: {},
  js: {}
}

function getCssClassName(moduleMapping, cssModuleName)
{
  var cssClassName = objectGet(moduleMapping, cssModuleName)
  if (!cssClassName)
    throw new Error(`CSS module ${cssModuleName} is not found`)

  if (typeof cssClassName !== "string")
    throw new Error(`CSS module ${cssModuleName} is not a string`)

  return cssClassName
}

function posthtmlCssModules(moduleMapping)
{
  return function(tree)
  {
    tree.match({ attrs: { "css-module": /\w+/ } }, (node) =>
    {
      var attrs = parseAttrs(node.attrs)
      var cssModuleName = attrs["css-module"]
      delete attrs["css-module"]

      attrs.class = attrs.class || []
      attrs.class.push(getCssClassName(moduleMapping, cssModuleName))
      node.attrs = attrs.compose()

      return node
    })
  }
}

var templateMinifyOptions =
{
  collapseWhitespace: true,
  removeComments: true,
  collapseBooleanAttributes: true,
  removeAttributeQuotes: true,
  useShortDoctype: true,
  removeEmptyAttributes: true,
  removeOptionalTags: true
}

export function getContentFromNode(node)
{
  var content = deindent(parse5.serialize(node.content || node)).trim()
  return content ? `${content}\n` : content
}

function convertFragmentIntoNodeMap(fragment)
{
  var nodes = {}
  fragment.childNodes.forEach((child) =>
  {
    // Ignore text (typically just white space) and comment nodes
    if (child.nodeName === "#text" || child.nodeName === "#comment")
      return

    var content = getContentFromNode(child)
    nodes[child.nodeName] = content
  })

  return nodes
}

export function cleanTemplateText(text)
{
  return text.split("\n").map((line) => line.trim()).join("\n")
}

export function generateHash(filename)
{
  const relPath = pathModule.relative(process.cwd(), filename)
  return crc.crc32(relPath).toString(16)
}

export function generateScopedName(name, filename)
{
  return `${name}-${generateHash(filename)}`
}

export function generateScopedNameFilename(name, filename)
{
  return `${pathModule.basename(filename).split('.')[0]}-${name}`
}

export default function vueSplitPlugin(config={})
{
  var moduleMapping = null

  function processStyle(done, text, path, base)
  {
    if (!text)
      return done()

    let scopeNameFn = generateScopedName

    if ( config.cssFilenameScoped ) {
      scopeNameFn = generateScopedNameFilename
    }

    return postcss([
      postcssModules({
        generateScopedName: scopeNameFn,
        getJSON: function(cssFileName, json)
        {
          moduleMapping = json
        }
      })
    ])
    .process(text, {
      from: path
    })
    .then((result) =>
    {
      if (memCache.css[path] === result.css)
        return done()

      memCache.css[path] = result.css

      var cssObj = new File({
        contents: new Buffer(result.css),
        path: path.replace(".vue", ".css"),
        base: base
      })

      return done(null, cssObj)
    })
  }

  var minifyTemplate = true

  function processTemplate(done, text, path, base)
  {
    if (!text)
      return done()

    var warnings = templateValidate(text)
    warnings.forEach((msg) =>
    {
      /* eslint no-console: 0 */
      console.warn(msg)
    })

    return posthtml([
      posthtmlCssModules(moduleMapping)
    ])
    .process(text)
    .then((result) =>
    {
      if (memCache.html[path] === result.html)
        return done()

      memCache.html[path] = result.html

      try
      {
        var html = minifyTemplate ? htmlMinifier.minify(result.html, templateMinifyOptions) : cleanTemplateText(result.html)

        new File({
          contents: new Buffer(html),
          path: path.replace(".vue", ".html")
        })
      }
      catch (exc)
      {
        console.error(`Problem during template processing: ${exc}`)
        return done(exc)
      }

      var jsHeader = `/* Generated by gulp-vuesplit - Edit the vue file instead. */\n/* eslint-disable */\n`
      var jsModule = `${jsHeader}export default ${JSON.stringify(html)}`
      var jsObj = new File({
        contents: new Buffer(jsModule),
        path: path.replace(".vue", ".html.js"),
        base: base
      })

      return done(null, jsObj)
    })
  }

  function processScript(done, text, path, base)
  {
    if (!text)
      return done()

    if (memCache.js[path] === text)
      return done()

    memCache.js[path] = text

    var fileObj = new File({
      contents: new Buffer(text),
      path: path.replace(".vue", ".js"),
      base: base
    })

    return done(null, fileObj)
  }

  function processHash(done, path, base)
  {
    const text = JSON.stringify({
      hash: generateHash(path)
    })

    const fileObj = new File({
      contents: new Buffer(text),
      path: path.replace(".vue", ".json"),
      base: base
    })

    return done(null, fileObj)
  }


  function transform(file, encoding, callback)
  {
    /* eslint no-invalid-this: 0 */

    if (file.isNull())
      return callback(null, file)

    if (file.isStream())
      return callback(new gutil.PluginError("gulp-vuesplit", "Streams are not supported"))

    var content = file.contents.toString("utf8")
    var fragment = parse5.parseFragment(content, {
      locationInfo: true
    })

    var nodes = convertFragmentIntoNodeMap(fragment)
    var self = this
    var filePath = file.path
    var fileBase = file.base

    return series([
      function(done)
      {
        processStyle(done, nodes.style, filePath, fileBase)
      },
      function(done)
      {
        processTemplate(done, nodes.template, filePath, fileBase)
      },
      function(done)
      {
        processScript(done, nodes.script, filePath, fileBase)
      },
      function(done)
      {
        processHash(done, filePath, fileBase)
      }
    ],
    (err, results) =>
    {
      if (err)
        return callback(new gutil.PluginError("gulp-vuesplit", err))

      results.forEach((resultFile) => resultFile && self.push(resultFile))
      return callback()
    })
  }

  return through.obj(transform)
}
